#!/usr/bin/env bash
set -euo pipefail

DB="/ai_data/ebooks/_corpus_index/unified_fts.sqlite"

if [[ $# -lt 1 ]]; then
  echo "Usage: library_search 'query' [limit]"
  echo "Examples:"
  echo "  library_search 'melchizedek' 10"
  echo "  library_search 'bullinger NEAR decades' 10"
  echo "  library_search 'bullinger NEAR/10 decades' 10   # auto-rewritten for FTS5"
  echo '  library_search "bullinger AND rel_path:\"Christian/Reformation/Bullinger\"" 10'
  exit 2
fi

Q="$1"
LIMIT="${2:-20}"

# Ensure LIMIT is an integer
if ! [[ "$LIMIT" =~ ^[0-9]+$ ]]; then
  echo "Error: limit must be an integer" >&2
  exit 2
fi

REL_FILTER=""

# Extract rel_path:"..."; remove it from Q *and* remove any adjacent AND/OR
if [[ "$Q" =~ rel_path:\"([^\"]+)\" ]]; then
  REL_FILTER="${BASH_REMATCH[1]}"

  # Remove the clause with a preceding boolean operator, if present
  Q="${Q/ AND rel_path:\"$REL_FILTER\"/}"
  Q="${Q/ OR rel_path:\"$REL_FILTER\"/}"

  # Or remove it with a trailing boolean operator, if present
  Q="${Q/rel_path:\"$REL_FILTER\" AND /}"
  Q="${Q/rel_path:\"$REL_FILTER\" OR /}"

  # Fallback: remove the bare clause
  Q="${Q/rel_path:\"$REL_FILTER\"/}"

  # Normalize whitespace
  Q="$(echo "$Q" | awk '{$1=$1; print}')"
fi
# Strip any dangling boolean operator at either end

Q="$(echo "$Q" | sed -E 's/^(AND|OR)[[:space:]]+//I; s/[[:space:]]+(AND|OR)$//I')"
Q="$(echo "$Q" | awk '{$1=$1; print}')"

# If query became empty after stripping rel_path, match everything and rely on rel_path filter
if [[ -z "$Q" ]]; then
  Q="*"
fi

# Escape single quotes for sqlite3 meta-command string literal
Q_ESC=${Q//\'/\'\'}

sqlite3 -separator $'\t' "$DB" <<SQL | awk -F'\t' '{ printf "\n%s\n%s\n", $1, $2 }'
.parameter init
.parameter set \$q '$Q_ESC'

select
  rel_path,
  snippet(docs_fts, 1, '[', ']', 'â€¦', 14)
from docs_fts
where docs_fts match \$q
$( [[ -n "$REL_FILTER" ]] && printf "  and rel_path like '%%%s/%%'\n" "${REL_FILTER//\'/\'\'}" )
limit $LIMIT;
SQL
