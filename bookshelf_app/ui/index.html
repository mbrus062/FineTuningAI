<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bookshelf</title>

    <style>
      :root {
        --bg: #ffffff;
        --border: #e6e6e6;
        --muted: #666;
        --text: #111;
        --panel: #fafafa;
        --shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
        --radius: 14px;
      }

      body {
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        gap: 12px;
        align-items: center;
      }

      header .title {
        font-weight: 900;
        font-size: 18px;
        letter-spacing: 0.2px;
      }

      header input {
        flex: 1;
        padding: 9px 12px;
        border: 1px solid #cfcfcf;
        border-radius: 12px;
      }

      header .right {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .muted {
        color: var(--muted);
        font-size: 12px;
      }

      .pillbtn {
        padding: 8px 10px;
        border: 1px solid #cfcfcf;
        border-radius: 999px;
        background: white;
        cursor: pointer;
        font-size: 12px;
      }
      .pillbtn:hover {
        border-color: #a9a9a9;
      }
      .pillbtn.active {
        border-color: #666;
        box-shadow: var(--shadow);
      }

      main {
        display: grid;
        height: calc(100vh - 54px);
        min-height: 0;
      }

      body.mode-normal main {
        grid-template-columns: 280px minmax(600px, 1.2fr) 2fr;
      }
      body.mode-shelf main {
        grid-template-columns: 280px 1fr 520px;
      }
      body.mode-shelfmax main {
        grid-template-columns: 0px 1fr 0px;
      }

      body.mode-shelfmax .pane:first-child {
        display: none;
      }
      body.mode-shelfmax .pane:last-child {
        display: none;
      }

      .pane {
        overflow: auto;
        min-height: 0;
        min-width: 0;
        border-right: 1px solid var(--border);
      }
      .pane:last-child {
        border-right: 0;
      }

      /* Left: filters */
      .filters {
        padding: 12px;
        display: grid;
        gap: 10px;
      }
      .filters .box {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 12px;
      }
      .filters .box h3 {
        margin: 0 0 8px 0;
        font-size: 12px;
        color: var(--muted);
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      select {
        width: 100%;
        padding: 9px 10px;
        border: 1px solid #cfcfcf;
        border-radius: 12px;
        background: white;
      }

      /* Middle: list view */
      .list {
        padding: 12px;
      }
      .row {
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: var(--radius);
        margin-bottom: 10px;
        cursor: pointer;
        background: white;
      }
      .row:hover {
        border-color: #c7c7c7;
        box-shadow: var(--shadow);
      }
      .row .t {
        font-weight: 800;
      }
      .row .m {
        color: #555;
        font-size: 12px;
        margin-top: 4px;
      }

      /* Middle: bookshelf view */
      .shelfWrap {
        padding: 14px;
      }
      .shelfTopBar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      .shelfNote {
        font-size: 12px;
        color: var(--muted);
      }

      .shelf {
        background:
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.55),
            rgba(255, 255, 255, 0) 28%
          ),
          repeating-linear-gradient(
            90deg,
            rgba(120, 80, 40, 0.18) 0px,
            rgba(120, 80, 40, 0.18) 10px,
            rgba(90, 60, 30, 0.18) 14px,
            rgba(120, 80, 40, 0.18) 22px
          ),
          linear-gradient(
            180deg,
            rgba(120, 78, 38, 0.22),
            rgba(90, 58, 28, 0.22)
          );
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 18px;
        padding: 14px 14px 18px 14px;
        box-shadow: var(--shadow);
        min-height: 280px;
      }

      /* IMPORTANT: this fixes the single-column issue */
      .spines {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: flex-end;
      }

      .spine {
        width: 34px;
        border-radius: 9px;
        border: 1px solid rgba(0, 0, 0, 0.22);
        cursor: pointer;
        position: relative;
        overflow: hidden;

        box-shadow:
          0 8px 14px rgba(0, 0, 0, 0.08),
          inset 0 0 0 1px rgba(255, 255, 255, 0.18);

        background:
          linear-gradient(
            90deg,
            color-mix(in srgb, var(--spineBase) 90%, white 10%),
            color-mix(in srgb, var(--spineBase) 78%, white 22%) 50%,
            color-mix(in srgb, var(--spineBase) 90%, white 10%)
          ),
          var(--spineTex);

        background-size:
          auto,
          220px 220px;
        background-blend-mode: normal, overlay;

        transform: translateY(0) translateX(0);
        transition:
          transform 0.1s ease,
          box-shadow 0.1s ease,
          filter 0.1s ease;
      }

      .spine:hover {
        transform: translateY(-5px) translateX(6px);
        filter: saturate(1.06) contrast(1.02);
        box-shadow:
          0 16px 26px rgba(0, 0, 0, 0.16),
          inset 0 0 0 1px rgba(255, 255, 255, 0.16);
      }

      /* subtle “cap” at top/bottom like binding */
      .spine::before,
      .spine::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        height: 18px;
        background: rgba(255, 255, 255, 0.22);
        pointer-events: none;
      }
      .spine::before {
        top: 0;
      }
      .spine::after {
        bottom: 0;
        background: rgba(0, 0, 0, 0.06);
      }

      /* Center text block inside spine */
      .spineText {
        position: absolute;
        inset: 6px 4px 6px 4px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 10px;
        pointer-events: none;
      }

      .spineTitle,
      .spineAuthor {
        writing-mode: vertical-rl;
        text-orientation: mixed;
        transform: rotate(180deg);
        text-align: center;
        color: rgba(0, 0, 0, 0.9);
        text-shadow:
          0 1px 0 rgba(255, 255, 255, 0.75),
          0 -1px 0 rgba(0, 0, 0, 0.18);
      }

      .spineTitle {
        font-weight: 800;
        font-size: 11px;
        line-height: 1.05;
        letter-spacing: 0.3px;
        background: rgba(255, 255, 255, 0.22);
        border-radius: 10px;
        padding: 6px 4px;
      }

      .spineAuthor {
        font-size: 11px;
        opacity: 0.85;
        background: rgba(255, 255, 255, 0.18);
        border-radius: 10px;
        padding: 6px 4px;
      }

      .shelfBoard {
        margin-top: 14px;
        height: 16px;
        border-radius: 999px;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.1),
          rgba(0, 0, 0, 0.03)
        );
        border: 1px solid rgba(0, 0, 0, 0.06);
      }

      /* Right: reader */
      .reader {
        padding: 12px;
        height: 100%;
        min-height: 0;
        display: flex;
        flex-direction: column;
      }

      .badge {
        display: inline-block;
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        margin-right: 6px;
        background: white;
      }

      .topline {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: center;
        margin-bottom: 10px;
      }

      button {
        padding: 8px 10px;
        border: 1px solid #cfcfcf;
        border-radius: 12px;
        background: white;
        cursor: pointer;
      }
      button:hover {
        border-color: #a9a9a9;
      }

      .hr {
        border: 0;
        border-top: 1px solid var(--border);
        margin: 12px 0;
      }

      .modeHidden {
        display: none;
      }

      iframe {
        width: 100%;
        height: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: white;
      }
    </style>
  
<style id="bs-spine-debug-css">
  .spine { outline: 2px solid rgba(255,0,0,0.35); outline-offset: 2px; }
  .spine:hover { outline-color: rgba(0,255,120,0.75); }
</style>

</head>

  <body>
    <header>
      <div class="title">Bookshelf</div>
      <input id="q" placeholder="Search title/author/path…" />
      <div class="right">
        <button class="pillbtn active" id="btnShelf">Shelf</button>
        <button class="pillbtn" id="btnList">List</button>
        <button
          class="pillbtn"
          id="layoutBtn"
          title="Cycle layout: normal → shelf → shelf max"
        >
          Layout
        </button>
        <div class="muted" id="count">Loading…</div>
      </div>
    </header>

    <main>
      <!-- LEFT -->
      <div class="pane">
        <div class="filters">
          <div class="box">
            <h3>Filters</h3>
            <select id="trad"></select>
            <div style="height: 10px"></div>
            <select id="source"></select>
            <div style="height: 10px"></div>
            <select id="lang"></select>
            <div style="height: 10px"></div>
            <select id="status"></select>
          </div>

          <div class="box">
            <h3>Display</h3>
            <div class="muted" id="displayNote">
              Shelf view shows a capped number of spines for speed.
            </div>
          </div>
        </div>
      </div>

      <!-- MIDDLE: SHELF VIEW -->
      <div class="pane" id="paneShelf">
        <div class="shelfWrap">
          <div class="shelfTopBar">
            <div class="shelfNote" id="shelfNote">Loading…</div>
            <div>
              <button
                id="shuffleBtn"
                title="Reorder spines (deterministic by default)"
              >
                Shuffle
              </button>
            </div>
          </div>

          <div class="shelf">
            <div class="spines" id="spines"></div>
            <div class="shelfBoard"></div>
          </div>
        </div>
      </div>

      <!-- MIDDLE: LIST VIEW -->
      <div class="pane modeHidden" id="paneList">
        <div class="list" id="list"></div>
      </div>

      <!-- RIGHT -->
      <div class="pane">
        <div class="reader">
          <div class="topline">
            <div>
              <div id="rt" style="font-weight: 900; font-size: 16px">
                Select a book
              </div>
              <div class="muted" id="rp"></div>
            </div>
            <div style="display: flex; gap: 8px">
              <button id="copyBtn" disabled>Copy path</button>
              <button id="openBtn" disabled>Open reader</button>
            </div>
          </div>

          <div id="badges"></div>
          <div class="hr"></div>

          <div style="flex: 1; min-height: 0">
            <iframe id="pdfFrame" title="PDF preview"></iframe>
          </div>
        </div>
      </div>
    </main>

    <script>
      let INDEX = [];
      let FILTERED = [];
      let SELECTED = null;

      let VIEW = "shelf";
      const SHELF_MAX = 50000;
      let SHUFFLED = false;

      const el = (id) => document.getElementById(id);

      const LAYOUTS = ["mode-normal", "mode-shelf", "mode-shelfmax"];
      let LAYOUT_IDX = 0;

      function applyLayout() {
        document.body.classList.remove(...LAYOUTS);
        document.body.classList.add(LAYOUTS[LAYOUT_IDX]);
      }

      function setupLayoutButton() {
        const btn = el("layoutBtn");
        if (!btn) return;
        btn.onclick = () => {
          LAYOUT_IDX = (LAYOUT_IDX + 1) % LAYOUTS.length;
          applyLayout();
        };
        applyLayout();
      }

      function uniq(arr) {
        return Array.from(new Set(arr)).sort((a, b) => a.localeCompare(b));
      }

      function fillSelect(sel, values, label) {
        sel.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = `All ${label}`;
        sel.appendChild(opt0);

        for (const v of values) {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = v;
          sel.appendChild(o);
        }
      }

      function setText(node, text) {
        node.textContent = text == null ? "" : String(text);
      }

      function hash32(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }

      function inferAuthor(e) {
        const a = (e.author || "").trim();
        if (a) return a;

        // Try parse from filename: "Title - Author, 2007 (157p).pdf"
        const p = (e.pdf_path || e.rel_path || "").toString();
        const file = p.split("/").pop() || "";
        const base = file.replace(/\.(pdf|epub|djvu|txt)$/i, "").trim();

        const parts = base.split(" - ");
        if (parts.length >= 2) {
          const right = parts.slice(1).join(" - ").trim();
          // take up to first comma if present
          const comma = right.indexOf(",");
          const guess = (comma >= 0 ? right.slice(0, comma) : right).trim();
          if (guess && guess.length >= 2) return guess;
        }
        return "";
      }

      function inferSeriesFromPath(e) {
        const p = (e.rel_path || e.pdf_path || "").toString();
        if (!p) return "";

        const parts = p.split("/").filter(Boolean);

        const bad = new Set([
          "pdf",
          "PDF",
          "scans",
          "Scan",
          "Scans",
          "_incoming",
          "_imports",
          "_digested",
        ]);

        const volIdx = parts.findIndex((s) => /^vol[_\s-]*\d+/i.test(s));
        if (volIdx > 0) {
          const candidate = parts[volIdx - 1];
          if (candidate && !bad.has(candidate)) return candidate;
        }

        for (let i = parts.length - 1; i >= 0; i--) {
          const seg = parts[i];
          if (seg.includes(".")) continue;
          if (bad.has(seg)) continue;
          if (/^vol[_\s-]*\d+/i.test(seg)) continue;
          return seg;
        }

        return "";
      }

      function prettyFolderName(s) {
        return (s || "").replace(/_+/g, " ").replace(/\s+/g, " ").trim();
      }

      function displayTitle(e) {
        let t = (e.spine_title || e.title || "").trim();

        t = t.replace(/\.(pdf|epub|djvu|txt)$/gi, "");
        t = t.replace(/_+/g, " ");
        t = t.replace(/\[[^\]]*\]/g, "");
        t = t.replace(/\([^\)]*\)/g, "");
        t = t.replace(/\s+/g, " ").trim();

        const volMatch = t.match(/^(vol(?:ume)?\.?\s*\d+)/i);
        if (volMatch) {
          const volPart = volMatch[1];
          const seriesRaw = inferSeriesFromPath(e);
          const series = prettyFolderName(seriesRaw);
          if (series.length > 3) t = `${series} — ${volPart}`;
        }

        return t || "(untitled)";
      }

      function spineStyleFor(e) {
        const key = `${e.title}|${inferAuthor(e)}|${e.rel_path || e.pdf_path || ""}`;
        const h = hash32(key);
        const hue = h % 360;
        const sat = 28 + (h % 18);
        const light = 78 - (h % 14);
        const bg = `hsl(${hue} ${sat}% ${light}%)`;
        const height = 210 + (h % 55);
        return { bg, height };
      }

      function applyFilters() {
        const q = el("q").value.trim().toLowerCase();
        const trad = el("trad").value;
        const source = el("source").value;
        const lang = el("lang").value;
        const status = el("status").value;

        FILTERED = INDEX.filter((e) => {
          if (trad && (e.tradition || "Unknown") !== trad) return false;
          if (source && (e.source || "Unknown") !== source) return false;
          if (lang && (e.language || "Unknown") !== lang) return false;
          if (status && (e.status || "Unknown") !== status) return false;

          if (q) {
            const hay =
              `${e.title || ""} ${inferAuthor(e)} ${e.rel_path || ""} ${e.pdf_path || ""}`.toLowerCase();
            if (!hay.includes(q)) return false;
          }
          return true;
        });

        el("count").textContent = `${FILTERED.length.toLocaleString()} items`;
        render();
      }

      function render() {
        if (VIEW === "list") renderList();
        else renderShelf();
      }

      function renderList() {
        const list = el("list");
        list.innerHTML = "";

        const max = 400;
        const slice = FILTERED.slice(0, max);

        for (const e of slice) {
          const div = document.createElement("div");
          div.className = "row";

          const t = document.createElement("div");
          t.className = "t";
          setText(t, displayTitle(e));

          const m1 = document.createElement("div");
          m1.className = "m";
          setText(
            m1,
            `${inferAuthor(e) || "Unknown"} · ${e.language || "Unknown"} · ${e.status || "Unknown"}`,
          );

          const m2 = document.createElement("div");
          m2.className = "m";
          setText(m2, e.pdf_path || e.rel_path || "");

          div.appendChild(t);
          div.appendChild(m1);
          div.appendChild(m2);

          div.onclick = () => loadEntry(e);
          list.appendChild(div);
        }

        if (FILTERED.length > max) {
          const more = document.createElement("div");
          more.className = "muted";
          more.textContent = `Showing first ${max}. Refine search to narrow.`;
          list.appendChild(more);
        }
      }

      function renderShelf() {
        const sp = el("spines");
        sp.innerHTML = "";

        let slice = FILTERED.slice(0, SHELF_MAX);

        if (SHUFFLED) {
          slice = slice
            .slice()
            .sort((a, b) => hash32(a.id || "") - hash32(b.id || ""))
            .reverse();
        }

        el("shelfNote").textContent =
          `Showing ${slice.length.toLocaleString()} spines (cap=${SHELF_MAX.toLocaleString()}). Refine filters/search to browse.`;

        for (const e of slice) {
          const d = document.createElement("div");
          d.className = "spine";

          const st = spineStyleFor(e);
          d.style.setProperty("--spineBase", st.bg);
          d.style.height = st.height + "px";

          const w = 28 + (hash32(e.id || "") % 17);
          d.style.width = w + "px";

          const tex =
            hash32(e.id || "") % 3 === 0
              ? 'url("/_bookshelf/assets/tex_leather.png")'
              : 'url("/_bookshelf/assets/tex_cloth.png")';
          d.style.setProperty("--spineTex", tex);

          d.title = `${displayTitle(e)}\n${inferAuthor(e)}\n${e.pdf_path || e.rel_path || ""}`;

          const box = document.createElement("div");
          box.className = "spineText";

          const title = document.createElement("div");
          title.className = "spineTitle";
          title.textContent = displayTitle(e);

          box.appendChild(title);

          const aName = inferAuthor(e);
          if (aName) {
            const a = document.createElement("div");
            a.className = "spineAuthor";
            a.textContent = aName;
            box.appendChild(a);
          }

          d.appendChild(box);

          d.onclick = (ev) => {
            // BS FORCE SERVER SAVE: keep absolute pdf path on spine element
            try {
              d.dataset.abs = (e.pdf_path || e.rel_path || '');
              d.setAttribute('data-abs', (e.pdf_path || e.rel_path || ''));
            } catch(_e) {}

            if (ev.shiftKey) return loadEntry(e); // Shift+click = embedded pane
            window.open(
              `/view?id=${encodeURIComponent(e.id)}`,
              "_blank",
              "noopener,noreferrer",
            );
          };

          sp.appendChild(d);
        }
      }

      async function loadEntry(e) {
        SELECTED = e;

        el("rt").textContent = displayTitle(e);
        el("rp").textContent = e.pdf_path || e.rel_path || "";

        el("badges").innerHTML = `
          <span class="badge">${inferAuthor(e) || "Unknown"}</span>
          <span class="badge">${e.language || "Unknown"}</span>
          <span class="badge">${e.status || "Unknown"}</span>
        `;

        el("copyBtn").disabled = false;
        el("copyBtn").onclick = async () => {
          await navigator.clipboard.writeText(e.pdf_path || e.rel_path || "");
        };

        el("openBtn").disabled = false;
        el("openBtn").onclick = () =>
          window.open(
            `/view?id=${encodeURIComponent(e.id)}`,
            "_blank",
            "noopener,noreferrer",
          );

        el("pdfFrame").src = `/api/pdf?id=${encodeURIComponent(e.id)}`;
      }

      function setView(v) {
        VIEW = v;
        el("btnShelf").classList.toggle("active", v === "shelf");
        el("btnList").classList.toggle("active", v === "list");
        el("paneShelf").classList.toggle("modeHidden", v !== "shelf");
        el("paneList").classList.toggle("modeHidden", v !== "list");
        render();
      }

      async function boot() {
        const r = await fetch("/api/index");
        const data = await r.json();
        INDEX = data.entries || [];

        fillSelect(
          el("trad"),
          uniq(INDEX.map((e) => e.tradition || "Unknown")),
          "traditions",
        );
        fillSelect(
          el("source"),
          uniq(INDEX.map((e) => e.source || "Unknown")),
          "sources",
        );
        fillSelect(
          el("lang"),
          uniq(INDEX.map((e) => e.language || "Unknown")),
          "languages",
        );
        fillSelect(
          el("status"),
          uniq(INDEX.map((e) => e.status || "Unknown")),
          "statuses",
        );

        ["trad", "source", "lang", "status"].forEach((id) =>
          el(id).addEventListener("change", applyFilters),
        );

        el("q").addEventListener("input", () => {
          window.clearTimeout(window._t);
          window._t = setTimeout(applyFilters, 120);
        });

        el("btnShelf").addEventListener("click", () => setView("shelf"));
        el("btnList").addEventListener("click", () => setView("list"));

        el("shuffleBtn").addEventListener("click", () => {
          SHUFFLED = !SHUFFLED;
          renderShelf();
        });

        FILTERED = INDEX;
        applyFilters();
      }

      setupLayoutButton();
      boot();
    
// BS right-click editor loaded




// BS SERVER SAVE MODALPATH v1 (autopatch)
(function(){
  const modal = document.getElementById("bs-edit-modal");
  if(!modal){ console.warn("BS: modal not found"); return; }

  // Helper: try hard to get an absolute pdf path from a spine element
  function getAbsPdfPathFromSpineEl(el){
    if(!el) return "";
    // common attributes we have seen
    const candidates = [
      el.getAttribute("data-path"),
      el.getAttribute("data1"),
      (el.dataset ? (el.dataset.path || el.dataset.pdfPath || el.dataset.pdf_path || el.dataset.pdfpath) : "")
    ].filter(Boolean);

    for(const c of candidates){
      const s = String(c).trim();
      if(s.startsWith("/") && s.toLowerCase().includes(".pdf")) return s;
      // If attribute is a blob of text, try to extract /...pdf (allow spaces)
      const m = s.match(/(\/ai_data\/ebooks\/[^\n\r]+?\.pdf)/i) || s.match(/(\/[^\n\r]+?\.pdf)/i);
      if(m && m[1] && m[1].startsWith("/")) return m[1].trim();
    }
    return "";
  }

  // Capture the last spine right-clicked and store absolute path directly on the modal
  document.addEventListener("contextmenu", (ev)=>{
    try{
      const spine = ev.target && ev.target.closest ? ev.target.closest(".spine") : null;
      if(!spine) return;
      const p = getAbsPdfPathFromSpineEl(spine);
      if(p){
        modal.dataset.pdfPath = p;
        // also store the spine element so we can update it after save
        window.__BS_LAST_SPINE_EL = spine;
        // BS ABS PATH CAPTURE v4 (autopatch)
        try {
          // Sometimes the contextmenu target is weird (header, overlay, etc).
          // Fallback to elementFromPoint so we still land on the spine.
          let s = spine;
          if (!s || !s.classList || !s.classList.contains("spine")) {
            const el = document.elementFromPoint(ev.clientX, ev.clientY);
            s = el && el.closest ? el.closest(".spine") : null;
            if (s) {
              window.__BS_LAST_SPINE_EL = s;
              console.log("BS ABS CAP v4: recovered spine via elementFromPoint()");
            }
          }

          const t = (window.__BS_LAST_SPINE_EL?.innerText || window.__BS_LAST_SPINE_EL?.textContent || "")
                      .replace(/\s+/g, " ").trim();
          const m = t.match(/(\/ai_data\/ebooks\/.*?\.pdf)/);
          if (m && m[1]) {
            window.__BS_OV_ABS_PATH = m[1];
            console.log("BS ABS PATH CAPTURED v4:", window.__BS_OV_ABS_PATH);
          } else {
            console.warn("BS ABS PATH CAP v4: no match in spine text:", t.slice(0, 220));
          }
        } catch (e) {
          console.warn("BS ABS PATH CAP v4 error:", e);
        }



        // BS ABS PATH CAPTURE v1 (autopatch)
        try {
          const t = (spine.getAttribute("title") || "");
          // title contains lines; last line includes absolute pdf path
          const m = t.match(/(\/.*?\.pdf)/);
          if (m && m[1] && m[1].startsWith("/")) {
            window.__BS_OV_ABS_PATH = m[1];
          }
        } catch (e) {}

      
        // BS: capture absolute PDF path for server override saves
        try {
          const p = (spine.getAttribute('data-path') || spine.getAttribute('data-abs') || spine.getAttribute('data1') ||
                    (spine.dataset ? (spine.dataset.abs || spine.dataset.path || spine.dataset.pdfPath || spine.dataset.pdf_path) : '') || '');
          // extract first absolute path ending in .pdf (allow spaces)
          const t = String(p);
          const mm = t.match(/(\/ai_data\/ebooks\/[\s\S]*?\.pdf)/i) || t.match(/(\/[\s\S]*?\.pdf)/i);
          const abs = (mm && mm[1]) ? mm[1].replace(/\s+/g,' ').trim() : '';
          if (abs && abs.startsWith('/')) window.__BS_OV_ABS_PATH = abs;
        } catch(e) {}
}
    }catch(e){}
  }, true);

  // Replace Save button behavior: always use modal.dataset.pdfPath first
  function setStatus(msg, ok){
    const st = document.getElementById("bs-edit-status");
    if(!st) return;
    st.textContent = msg || "";
    st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
  }

  async function saveToServer(){
    const path = (modal.dataset && modal.dataset.pdfPath) ? modal.dataset.pdfPath : "";
    if(!path || !path.startsWith("/") || !path.toLowerCase().includes(".pdf")){

    // BS ABS PATH FROM MODAL TEXT (autopatch)
    // Fallback: parse the visible modal text for an absolute /ai_data/ebooks/...pdf path
    try {
      const modal = document.getElementById("bs-ov-modal") || document.getElementById("bs-edit-modal");
      const txt = modal ? (modal.textContent || "") : "";
      const m = txt.match(/(\/ai_data\/ebooks\/[\s\S]*?\.pdf)/i);
      if (m && m[1] && (!window.__BS_OV_ABS_PATH || !String(window.__BS_OV_ABS_PATH).startsWith("/"))) {
        window.__BS_OV_ABS_PATH = m[1].replace(/\s+/g, " ").trim();
      }
    } catch(e) {}

      setStatus("ERROR: could not detect absolute PDF path.", false);
      return;
    }

    const title = (document.getElementById("bs-edit-title")?.value || "").trim();
    const author = (document.getElementById("bs-edit-author")?.value || "").trim();

    setStatus("Saving to server…", true);

    try{
      const r = await fetch("/api/override_path", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ path, title, author, hidden: false })
      });
      const j = await r.json().catch(()=> ({}));
      if(!r.ok){
        setStatus("ERROR saving: " + (j.detail ? JSON.stringify(j.detail) : (r.status+" "+r.statusText)), false);
        return;
      }

      setStatus("Saved to server overrides.json ✓", true);

      // Update the spine label immediately (optional but nice)
      try{
        const spine = window.__BS_LAST_SPINE_EL || null;
        if(spine && title){
          spine.setAttribute("title", title);
          // if there is visible text inside, update it
          // (safe: only touch if it looks like plain text)
          if(spine.childNodes && spine.childNodes.length === 1 && spine.childNodes[0].nodeType === Node.TEXT_NODE){
            spine.textContent = title;
          }
        }
      }catch(e){}
    }catch(e){
      setStatus("ERROR: request failed (see console).", false);
    }
  }

  // Bind in capture mode and block older handlers
  document.addEventListener("click", (ev)=>{
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save,#bs-edit-save") : null;
    if(!btn) return;
    ev.preventDefault();
    ev.stopPropagation();
    if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
    saveToServer();
  }, true);

  console.log("BS server save modalpath wiring loaded");
})();

</script>
  
<!-- BS RC EDIT (autopatch) -->

  <div style="position:relative; max-width:620px; margin:10vh auto; background:#111; color:#eee; border:1px solid rgba(255,255,255,0.15); border-radius:14px; padding:16px; box-shadow:0 20px 60px rgba(0,0,0,0.6);">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
      <div style="font-weight:800; font-size:16px;">Right-click editor is LIVE</div>
      <button id="bs-edit-close" style="background:transparent; color:#eee; border:1px solid rgba(255,255,255,0.25); border-radius:12px; padding:6px 10px; cursor:pointer;">Close</button>
    </div>
    <div style="margin-top:10px; font-size:13px; opacity:0.9;">
      You should be seeing this because we intercepted <code>contextmenu</code>.
    </div>
  </div>
</div>



<!-- BS RC EDIT MODAL TAILFIX (autopatch) -->

<!-- BS RC EDIT MODAL (spine editor) -->
<div id="bs-edit-modal" style="display:none; position:fixed; inset:0; z-index:99999;">
  <div id="bs-edit-backdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>

  <div style="position:relative; max-width:860px; margin:6vh auto; background:#111; color:#eee;
              border:1px solid rgba(255,255,255,0.15); border-radius:14px; padding:16px;
              box-shadow:0 20px 60px rgba(0,0,0,0.6);">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
      <div style="font-weight:800; font-size:16px;">Edit spine metadata (local overrides)</div>
      <button id="bs-edit-close"
        style="background:transparent; color:#eee; border:1px solid rgba(255,255,255,0.25);
               border-radius:12px; padding:6px 10px; cursor:pointer;">Close</button>
    </div>

    <div style="margin-top:10px; font-size:12px; opacity:0.9; line-height:1.35;">
      <div><span style="opacity:0.8;">Detected title:</span> <span id="bs-detected-title"></span></div>
      <div><span style="opacity:0.8;">Detected path:</span> <code id="bs-detected-path" style="color:#b7e1ff;"></code></div>
    </div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px;">
      <label style="display:block;">
        <div style="font-size:12px; opacity:0.85; margin-bottom:4px;">Override Title</div>
        <input id="bs-ov-title" type="text"
          style="width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.18);
                 background:#0b0b0b; color:#eee;">
      </label>
      <label style="display:block;">
        <div style="font-size:12px; opacity:0.85; margin-bottom:4px;">Override Author</div>
        <input id="bs-ov-author" type="text"
          style="width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.18);
                 background:#0b0b0b; color:#eee;">
      </label>
    </div>

    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:12px;">
      <div style="display:flex; gap:10px;">
        <button id="bs-ov-save"
          style="background:#1f6feb; border:none; color:#fff; border-radius:10px; padding:10px 14px; cursor:pointer;">
          Save (server)
        </button>
        <button id="bs-ov-clear"
          style="background:transparent; border:1px solid rgba(255,255,255,0.25); color:#eee; border-radius:10px;
                 padding:10px 14px; cursor:pointer;">
          Clear override
        </button>
      </div>
      <div id="bs-ov-status" style="font-size:12px; opacity:0.9;"></div>
    </div>
  </div>
</div>


<script id="bs-rc-edit-script">
(function(){
  const LS_KEY = "bookshelf_overrides_v1";
  let OV = {};
  try { OV = JSON.parse(localStorage.getItem(LS_KEY) || "{}"); } catch(e) { OV = {}; }
  function saveOV(){ /* server-backed now */ }

  function findPdfPath(el){
    if(!el) return "";
    for (const a of el.attributes || []) {
      const v = (a.value || "").trim();
      if (!v) continue;
      if (v.includes("/ai_data/") || v.toLowerCase().endsWith(".pdf")) return v;
    }
    const p = el.parentElement;
    if(p){
      for (const a of p.attributes || []) {
        const v = (a.value || "").trim();
        if (!v) continue;
        if (v.includes("/ai_data/") || v.toLowerCase().endsWith(".pdf")) return v;
      }
    }
    return "";
  }

  function detectedTitle(spine){
    return (spine && (spine.getAttribute("title") || spine.title || "")) || "";
  }

  function keyFor(spine){
    const p = findPdfPath(spine);
    if (p) return "path:" + p;
    const t = detectedTitle(spine);
    return "title:" + t;
  }

  function applyOverrideToSpine(spine){
    if(!spine) return;
    const k = keyFor(spine);
    const o = OV[k];
    if(!o) return;
    if(o.title && o.title.trim()){
      spine.setAttribute("title", o.title.trim());
    }
  }

  function setStatus(msg, ok=true){
    const st = document.getElementById("bs-ov-status");
    if(!st) return;
    st.textContent = msg || "";
    st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
  }

  function openEditorFor(spine){
    const modal = document.getElementById("bs-edit-modal");
    if(!modal){ console.warn("bs-edit-modal missing"); return; }

    modal._spine = spine;

    const t = detectedTitle(spine);
    const p = findPdfPath(spine);
    const k = keyFor(spine);

    // Capture absolute PDF path once at modal-open time (stable)
    try{
      let abs = p || "";

      // If findPdfPath didn't return a clean absolute path, fallback to parsing text
      if(!abs || !abs.startsWith("/")){
        const spineText = (spine && (spine.getAttribute("title") || spine.innerText || spine.textContent)) || "";
        const m = String(spineText).match(/(\/ai_data\/ebooks\/[\s\S]*?\.(?:pdf|djvu|epub|mobi))/i);
        if(m && m[1]) abs = m[1].replace(/\s+/g," ").trim();
      }

      if(abs && abs.startsWith("/")){
        modal.dataset.pdfPath = abs;
      }
    }catch(e){}
    const o = OV[k] || {};

    document.getElementById("bs-detected-title").textContent = t || "(none)";
    document.getElementById("bs-detected-path").textContent = p || "(not detected)";

    document.getElementById("bs-ov-title").value = o.title || "";
    document.getElementById("bs-ov-author").value = o.author || "";

    modal.style.display = "block";
    setStatus("Editing overrides (stored on server).", true);
    document.getElementById("bs-ov-title").focus();
  }

  function closeEditor(){
    const modal = document.getElementById("bs-edit-modal");
    if(modal) modal.style.display = "none";
    setStatus("");
  }

  function bestSpineFromEventTarget(t){
    // 1) the obvious case
    let spine = t && t.closest && t.closest(".spine");
    if(spine) return spine;

    // 2) click landed on children (title/author/text)
    spine = t && t.closest && t.closest(".spineTitle, .spineAuthor, .spineText");
    if(spine) return spine.closest(".spine") || spine;

    // 3) sometimes spine might be a div with a title attribute
    spine = t && t.closest && t.closest('div[title]');
    if(spine && (spine.classList.contains("spine") || spine.style.getPropertyValue("--spineBase"))) return spine;

    return null;
  }

  function wire(){
    const modal = document.getElementById("bs-edit-modal");
    const backdrop = document.getElementById("bs-edit-backdrop");
    const closeBtn = document.getElementById("bs-edit-close");
    const saveBtn = document.getElementById("bs-ov-save");
    const clearBtn = document.getElementById("bs-ov-clear");

    closeBtn && closeBtn.addEventListener("click", closeEditor);
    backdrop && backdrop.addEventListener("click", closeEditor);

    saveBtn && saveBtn.addEventListener("click", ()=>{
      const spine = modal && modal._spine;
      if(!spine){ setStatus("No spine selected.", false); return; }
      const k = keyFor(spine);
      OV[k] = {
        title: (document.getElementById("bs-ov-title").value || "").trim(),
        author: (document.getElementById("bs-ov-author").value || "").trim(),
        updated_at: new Date().toISOString(),
      };
      saveOV();
      applyOverrideToSpine(spine);
      setStatus("Saved locally.", true);
    });

    clearBtn && clearBtn.addEventListener("click", ()=>{
      const spine = modal && modal._spine;
      if(!spine){ setStatus("No spine selected.", false); return; }
      const k = keyFor(spine);
      delete OV[k];
      saveOV();
      setStatus("Cleared override (refresh to restore original tooltip if needed).", true);
    });

    // Apply overrides to any spines already rendered
    document.querySelectorAll(".spine").forEach(applyOverrideToSpine);

    // DEBUG + intercept only when we truly hit a spine-ish element
    document.addEventListener("click", function(ev){
  if(!ev.shiftKey) return;
  const s = ev.target.closest && ev.target.closest(".spine");
  console.log("BS SHIFT+CLICK target=", ev.target, " spine=", s);
}, true);

document.addEventListener("contextmenu", function(ev){
      const spine = bestSpineFromEventTarget(ev.target);
      console.log("BS contextmenu target=", ev.target, " spine=", spine);
      if(!spine) return; // normal menu elsewhere
      ev.preventDefault();
      openEditorFor(spine);
    }, true);

    console.log("BS SPINE EDITOR LOADED (debug matcher)");
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", wire, { once: true });
  } else {
    wire();
  }
})();

  // BS SERVER OVERRIDE WIRING (autopatch)
  // BS FORCE SERVER SAVE ACTIVE (autopatch)
  (function(){
    const modal = document.getElementById("bs-edit-modal");
    if(!modal) return;

    // When opening editor, stash absolute path from the clicked spine element
    // (We attach this by monkey-patching the existing openEditor if present.)
    const _oldOpen = window.openEditor || null;
    window.openEditor = function(e, spineEl){
      try {
        // spineEl is best; fall back to dataset already stored on modal by earlier code if any
        const abs = (spineEl && (spineEl.getAttribute("data-abs") || (spineEl.dataset && spineEl.dataset.abs))) || e.pdf_path || e.rel_path || "";
        if (abs) modal.dataset.pdfPath = abs;
      } catch(err) {}
      if (_oldOpen) return _oldOpen(e, spineEl);
    };

    // If existing code doesn’t call window.openEditor, add a capture hook on contextmenu to store spineEl.
    document.addEventListener("contextmenu", (ev)=>{
      const spine = ev.target.closest(".spine,[data-abs],[data-path]");
      if (spine && modal) {
        try { modal._lastSpineEl = spine; } catch(e) {}
        try {
          const abs = spine.getAttribute("data-abs") || (spine.dataset && (spine.dataset.abs || spine.dataset.path)) || "";
          if (abs) modal.dataset.pdfPath = abs;
        } catch(e) {}
      }
    }, true);

    // Force Save button to server endpoint
    const saveBtn = document.getElementById("bs-ov-save");
    const titleIn = document.getElementById("bs-ov-title");
    const authorIn = document.getElementById("bs-ov-author");
    const statusEl = document.getElementById("bs-ov-status");
    function setStatus(msg, ok=true){
      if(!statusEl) return;
      statusEl.textContent = msg || "";
      statusEl.style.color = ok ? "#b6fcb6" : "#ffb6b6";
    }

    if(saveBtn){
      saveBtn.textContent = "Save (server)";
      saveBtn.onclick = async (ev)=>{
        ev.preventDefault();
        const path = (modal && modal.dataset && modal.dataset.pdfPath) || "";
        const title = titleIn ? titleIn.value.trim() : "";
        const author = authorIn ? authorIn.value.trim() : "";
        if(!path || !path.startsWith("/")){
          setStatus("ERROR: No absolute PDF path captured for this spine.", false);
          console.warn("BS FORCE SERVER SAVE: missing path", {path});
          return;
        }

        setStatus("Saving to server…", true);
        try{
          const r = await fetch("/api/override_path", {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({path, title, author, hidden:false})
          });
          const j = await r.json().catch(()=> ({}));
          console.log("BS FORCE SERVER SAVE: response", r.status, j);

          if(!r.ok){
            setStatus("Server save failed: HTTP " + r.status, false);
            return;
          }

          setStatus("Saved to server overrides.json", true);

          // Instant visual update of the clicked spine title/tooltip
          try{
            const spineEl = modal._lastSpineEl || null;
            if(spineEl && title){
              const t = spineEl.querySelector(".spineTitle");
              if(t) t.textContent = title;
              spineEl.setAttribute("title", title);
            }
          } catch(e) {}
        } catch(err){
          console.warn("BS FORCE SERVER SAVE: fetch error", err);
          setStatus("Server save failed (network/error).", false);
        }
      };
    }
    console.log("BS FORCE SERVER SAVE ACTIVE");
  })();

  try {
    const modal = document.getElementById("bs-edit-modal");
    
const saveBtn = document.getElementById("bs-ov-save");
const clearBtn = document.getElementById("bs-ov-clear");

// === Server-backed overrides ===
function bsExtractPathFromModal() {
  // Prefer any variable you already track
  try {
    if (window.__BS_CURRENT_PATH && String(window.__BS_CURRENT_PATH).includes(".pdf")) return window.__BS_CURRENT_PATH;
  } catch(e) {}

  // Parse from the modal text ("Detected path: ...pdf")
  const modal = document.getElementById("bs-edit-modal");
  if (!modal) return "";
  const t = modal.textContent || "";
  const m = t.match(/Detected path:\s*([^\n\r]+?\.pdf)/i);
  if (m && m[1]) return m[1].trim();

  // Last resort: search for any /ai_data/ebooks/...pdf within modal
  const m2 = t.match(/\/ai_data\/ebooks\/[^\s]+?\.pdf/);
  return m2 ? m2[0].trim() : "";
}

async function bsPostOverride(payload){
  const r = await fetch("/api/override_path", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(payload),
  });
  const j = await r.json().catch(()=>({}));
  return {r,j};
}

if (saveBtn) {
  saveBtn.textContent = "Save (server)";
  saveBtn.addEventListener("click", async (ev) => {
    ev.preventDefault();
    ev.stopImmediatePropagation();

    const path = bsExtractPathFromModal();
    if (!path) { setStatus("Could not detect PDF path for this spine.", false); return; }

    const title = (document.getElementById("bs-ov-title")?.value || "").trim();
    const author = (document.getElementById("bs-ov-author")?.value || "").trim();

    const {r,j} = await bsPostOverride({path, title, author, hidden:false});
    if (!r.ok || !j.ok) {
      setStatus("Save failed: " + (j.error || ("HTTP " + r.status)), false);
      return;
    }
    setStatus("Saved to server overrides.json", true);
  }, true);
}

if (clearBtn) {
  clearBtn.addEventListener("click", async (ev) => {
    ev.preventDefault();
    ev.stopImmediatePropagation();

    const path = bsExtractPathFromModal();
    if (!path) { setStatus("Could not detect PDF path for this spine.", false); return; }

    const {r,j} = await bsPostOverride({path, clear:true});
    if (!r.ok || !j.ok) {
      setStatus("Clear failed: " + (j.error || ("HTTP " + r.status)), false);
      return;
    }
    setStatus("Cleared on server.", true);
  }, true);
}
clearBtn && clearBtn.addEventListener("click", async (ev)=>{
      ev.stopImmediatePropagation();

      const spine = modal && modal._spine;
      if(!spine){ _setStatus("No spine selected.", false); return; }
      const path = _findPdfPath(spine);
      if(!path){ _setStatus("Could not detect PDF path.", false); return; }

      try{
        const {r,j} = await postOverride({path, clear:true});
        if(!r.ok || !j.ok){
          _setStatus("Clear failed: " + (j.error || ("HTTP " + r.status)), false);
          return;
        }
        _setStatus("Cleared on server (refresh to restore original tooltip).", true);
      }catch(err){
        _setStatus("Clear error: " + err, false);
      }
    }, true);

    console.log("BS server override wiring loaded");
  } catch (e) {
    console.warn("BS server override wiring failed", e);
  }

</script>




<!-- BS SERVER WIRE V3 (autopatch) -->
<script id="bs-server-wire-v3">
(function(){
  function findModal(){
    // Prefer known modal container ids if present, else any visible overlay containing "Edit spine metadata"
    const byId = document.getElementById("bs-edit-modal");
    if (byId) return byId;
    const all = Array.from(document.querySelectorAll("div"));
    return all.find(d => (d.textContent||"").includes("Edit spine metadata")) || null;
  }

  function findPdfPathInModal(modal){
    const txt = modal ? (modal.textContent || "") : "";
    // match /ai_data/ebooks/... .pdf
    const m = txt.match(/\/ai_data\/ebooks\/[^ 

	]+?\.pdf/);
    return m ? m[0] : "";
  }

  function pickButtons(modal){
    const btns = modal ? Array.from(modal.querySelectorAll("button")) : [];
    const save = btns.find(b => (b.textContent||"").toLowerCase().includes("save")) || null;
    const clear = btns.find(b => (b.textContent||"").toLowerCase().includes("clear")) || null;
    return {save, clear};
  }

  function pickInputs(modal){
    const ins = modal ? Array.from(modal.querySelectorAll("input")) : [];
    // assume first two inputs are title/author
    const titleIn = ins[0] || null;
    const authorIn = ins[1] || null;
    return {titleIn, authorIn};
  }

  function setHint(modal, msg){
    if(!modal) return;
    // try to find the green hint text area
    const nodes = Array.from(modal.querySelectorAll("div,span,p"));
    const hint = nodes.find(n => (n.textContent||"").toLowerCase().includes("stored in this browser")) || null;
    if (hint) hint.textContent = msg;
  }

  async function postOverride(payload){
    const r = await fetch("/api/override_path", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(payload),
    });
    const j = await r.json().catch(()=>({}));
    return {r,j};
  }

  function wire(){
    const modal = findModal();
    if(!modal) return false;

    const {save, clear} = pickButtons(modal);
    const {titleIn, authorIn} = pickInputs(modal);

    if (save) save.textContent = "Save (server)";
    setHint(modal, "Editing overrides (stored on server).");

    // Capture-phase click hijack: beats existing local handler
    if (save && !save._bsServerV3){
      save.addEventListener("click", async (ev)=>{
        ev.preventDefault();
        ev.stopImmediatePropagation();

        const path = findPdfPathInModal(modal);
        if(!path){
          console.warn("BS V3: could not extract path from modal text");
          return;
        }
        const payload = {
          path,
          title: (titleIn?.value || "").trim(),
          author: (authorIn?.value || "").trim(),
        };

        const {r,j} = await postOverride(payload);
        if(!r.ok || !j.ok){
          console.warn("BS V3 save failed", r.status, j);
          return;
        }
        console.log("BS V3 saved", j);
      }, true);
      save._bsServerV3 = true;
    }

    if (clear && !clear._bsServerV3){
      clear.addEventListener("click", async (ev)=>{
        ev.preventDefault();
        ev.stopImmediatePropagation();

        const path = findPdfPathInModal(modal);
        if(!path){
          console.warn("BS V3: could not extract path from modal text");
          return;
        }
        const {r,j} = await postOverride({path, clear:true});
        if(!r.ok || !j.ok){
          console.warn("BS V3 clear failed", r.status, j);
          return;
        }
        console.log("BS V3 cleared", j);
      }, true);
      clear._bsServerV3 = true;
    }

    console.log("BS SERVER WIRE V3 ACTIVE");
    return true;
  }

  // The modal is created/used dynamically; retry until it’s there
  let tries = 0;
  const t = setInterval(()=>{
    tries++;
    if (wire() || tries > 80) clearInterval(t);
  }, 250);
})();

// BS CAPTURE SAVE OVERRIDE (autopatch)
(function(){
  function $(sel){ return document.querySelector(sel); }
  function setHint(msg, ok=true){
    // Try a few known hint/status locations; fall back to console
    const el = $("#bs-ov-hint") || $("#bs-ov-status") || $("#bs-edit-status");
    if (el){
      el.textContent = msg || "";
      el.style.color = ok ? "#b6fcb6" : "#ffb6b6";
    } else {
      console.log("BS HINT:", msg);
    }
  }

  function extractPdfPath(modal){
    // Best: dataset set by earlier code
    let p = (modal && modal.dataset && (modal.dataset.pdfPath || modal.dataset.path)) || "";
    if (p && p.startsWith("/")) return p;

    // Next: look for any text inside modal that contains an absolute path to a .pdf
    const t = (modal && modal.innerText) ? modal.innerText : "";
    // Prefer /ai_data/ebooks...pdf
    let m = t.match(/(\/ai_data\/ebooks\/[^\s]+?\.pdf)/i);
    if (m && m[1]) return m[1];

    // Generic absolute path to .pdf (last resort)
    m = t.match(/(\/[^\s]+?\.pdf)/i);
    if (m && m[1]) return m[1];

    return "";
  }

  function getTitleAuthor(modal){
    // Don’t depend on specific IDs — just grab inputs within the editor modal.
    // Most recent UI has two inputs: title then author.
    const inputs = modal ? Array.from(modal.querySelectorAll("input")) : [];
    const title = inputs[0] ? inputs[0].value.trim() : "";
    const author = inputs[1] ? inputs[1].value.trim() : "";
    return {title, author};
  }

  async function postOverride(path, title, author){
    const payload = {path, title, author, hidden:false};
    const r = await fetch("/api/override_path", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(payload),
    });
    const j = await r.json().catch(()=> ({}));
    console.log("BS CAPTURE SAVE: /api/override_path", r.status, j);
    return {ok: r.ok, status: r.status, json: j};
  }

  // Capture-phase click interceptor — beats any existing onclick assignments
  document.addEventListener("click", async (ev)=>{
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save") : null;
    if (!btn) return;

    // Stop any other handlers from running
    ev.preventDefault();
    ev.stopPropagation();
    if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();

    const modal = document.getElementById("bs-edit-modal") || document.querySelector("[id*='edit'][id*='modal']");
    if (!modal){
      setHint("ERROR: editor modal not found.", false);
      console.warn("BS CAPTURE SAVE: no modal found");
      return;
    }

    const path = (window.__BS_EXTRACT_PDF_PATH ? window.__BS_EXTRACT_PDF_PATH(modal) : extractPdfPath(modal));
    const {title, author} = getTitleAuthor(modal);

    console.log("BS CAPTURE SAVE: clicked", {path, title, author});

    if (!path || !path.startsWith("/")){
      setHint("ERROR: could not detect absolute PDF path for this spine.", false);
      return;
    }

    setHint("Saving to server…", true);
    try{
      const res = await postOverride(path, title, author);
      if (!res.ok){
        setHint("Server save failed: HTTP " + res.status, false);
        return;
      }
      setHint("Saved to server overrides.json", true);
    } catch(err){
      console.warn("BS CAPTURE SAVE: fetch error", err);
      setHint("Server save failed (exception).", false);
    }
  }, true);

  console.log("BS CAPTURE SAVE OVERRIDE active");
})();
</script>


<!-- BS UI FORCE SERVER SAVE v1 (autopatch) -->
<script>
(function(){
  function status(msg, ok){
    const st = document.getElementById("bs-ov-status") || document.getElementById("bs-edit-status");
    if(st){
      st.textContent = msg || "";
      st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
    } else {
      console.log("BS STATUS:", msg);
    }
  }

  function getModal(){
    return document.getElementById("bs-edit-modal");
  }

  function extractPdfPath(modal){
    // Prefer a stored attribute if your code sets it
    try{
      const dp = (modal.dataset && (modal.dataset.pdfPath || modal.dataset.path)) || "";
      if(dp && dp.startsWith("/")) return dp;
    }catch(e){}

    // Otherwise parse any absolute pdf path from modal text
    const t = (modal.innerText || modal.textContent || "");
    let m = t.match(/(\/ai_data\/ebooks\/[^\s]+?\.pdf)/i);
    if(m && m[1]) return m[1];
    m = t.match(/(\/[^\s]+?\.pdf)/i);
    return (m && m[1]) ? m[1] : "";
  }

  function getTitleAuthor(modal){
    const inputs = Array.from(modal.querySelectorAll("input"));
    return {
      title: inputs[0] ? inputs[0].value.trim() : "",
      author: inputs[1] ? inputs[1].value.trim() : "",
    };
  }

  async function postOverride(path, title, author){
    const r = await fetch("/api/override_path", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({path, title, author, hidden:false}),
    });
    const j = await r.json().catch(()=>({}));
    console.log("BS UI FORCE SAVE response", r.status, j);
    return {r,j};
  }

  // Capture-phase click handler beats any existing onclick/addEventListener
  document.addEventListener("click", async (ev)=>{
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save") : null;
    if(!btn) return;

    ev.preventDefault();
    ev.stopPropagation();
    if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();

    const modal = getModal();
    if(!modal){ status("ERROR: modal not found", false); return; }

    const path = (window.__BS_EXTRACT_PDF_PATH ? window.__BS_EXTRACT_PDF_PATH(modal) : extractPdfPath(modal));
    const {title, author} = getTitleAuthor(modal);

    console.log("BS UI FORCE SAVE posting", {path, title, author});
    if(!path || !path.startsWith("/")){
      status("ERROR: could not detect absolute PDF path.", false);
      return;
    }

    // Visual feedback on button
    const oldText = btn.textContent;
    btn.textContent = "Saving…";

    status("Saving to server…", true);
    try{
      const {r,j} = await postOverride(path, title, author);
      if(!r.ok || !j.ok){
        status("Save failed: " + (j.error || ("HTTP " + r.status)), false);
        btn.textContent = oldText;
        return;
      }
      status("Saved ✅", true);
      btn.textContent = "Saved ✅";
      setTimeout(()=>{ btn.textContent = oldText; }, 900);
    }catch(e){
      console.warn("BS UI FORCE SAVE error", e);
      status("Save failed (exception).", false);
      btn.textContent = oldText;
    }
  }, true);

  // Ensure the label says server
  window.addEventListener("load", ()=>{
    const b = document.getElementById("bs-ov-save");
    if(b && b.textContent.toLowerCase().includes("local")){
      b.textContent = "Save (server)";
    }
  });

  console.log("BS UI FORCE SERVER SAVE v1 active");
})();
</script>


<!-- BS UI PATHFIX v1 (autopatch) -->
<script>
(function(){
  // Capture last right-clicked spine element + any pdf path we can find on it.
  window.__BS_LAST_PDF_PATH = "";

function extractAbsPdfPathFromAnyText(t){
  try{
    t = String(t || "");
    const m = t.match(/(\/ai_data\/ebooks\/[\s\S]*?\.(?:pdf|djvu|epub|mobi))/i);
    return (m && m[1]) ? m[1].replace(/\s+/g," ").trim() : "";
  }catch(e){
    return "";
  }
}

function sniffPathFromText(t){
  try{
    t = String(t || "");

    // Prefer explicit "Detected path:" line (allows spaces)
    const m = t.match(/Detected path:\s*([^\n\r]+)/i);
    if(m && m[1]) return m[1].trim();

    // Fallback: find any absolute /ai_data/ebooks/...pdf path (allows spaces)
    const m2 = t.match(/(\/ai_data\/ebooks\/.*?\.(?:pdf|djvu|epub|mobi))/i);
    if(m2 && m2[1]) return m2[1].trim();

    return "";
  } catch(e){
    return "";
  }
}

  document.addEventListener("contextmenu", (ev)=>{
    try{
      const el = ev.target && ev.target.closest ? ev.target.closest(".spine,[data-entry],[data-id],[data-path]") : null;
      if(!el) return;

      // Try several likely places
      let p = "";
      if(el.dataset){
        p = el.dataset.pdfPath || el.dataset.path || el.dataset.pdf_path || "";
      }
      if(!p) p = el.getAttribute("data-path") || "";
      if(!p) p = el.getAttribute("data1") || ""; // seen in your earlier console logs
      if(p && !p.includes(".pdf")) {
        // if it's some blob, try to extract a path from it
        const p2 = sniffPathFromText(p);
        if(p2) p = p2;
      }

      // Absolute-path check
      if(p && p.includes(".pdf") && p.startsWith("/")) {
        window.__BS_LAST_PDF_PATH = p;
      }
    }catch(e){}
  }, true);

  // Monkey-patch the force-save extractor if present:
  // It will now first check modal text "Detected path:" and then last right-clicked spine path.
  window.__BS_EXTRACT_PDF_PATH = function(modal){
    try{
      const t = (modal && (modal.innerText || modal.textContent)) || "";
      const p = sniffPathFromText(t);
      if(p && p.startsWith("/") && p.toLowerCase().endsWith(".pdf")) return p;
    }catch(e){}
    if(window.__BS_LAST_PDF_PATH) return window.__BS_LAST_PDF_PATH;
    return "";
  };

  console.log("BS UI PATHFIX v1 active");
})();


// BS SERVER SAVE PATHFROMMODAL v2

// BS SERVER SAVE PATHFROMMODAL v2 (autopatch)
(function(){
  function setStatus(msg, ok){
    const st = document.getElementById("bs-edit-status");
    if(!st) return;
    st.textContent = msg || "";
    st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
  }

  function extractPdfPath(s){
    if(!s) return "";
    const t = String(s).trim();
    // capture absolute path ending in .pdf (allow spaces)
    // prefer /ai_data/ebooks/... first, then any /...pdf
    let m = t.match(/(\/ai_data\/ebooks\/.+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    m = t.match(/(\/.+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    return "";
  }

  async function saveToServer(){
    const modal = document.getElementById("bs-edit-modal");
    const elPath = document.getElementById("bs-edit-path");

    // Strongest source of truth: whatever the modal is displaying as "Detected path"
    let path = extractPdfPath(elPath ? elPath.textContent : "");
    // fallback: any dataset path that might exist
    if(!path && modal && modal.dataset) path = extractPdfPath(modal.dataset.pdfPath || modal.dataset.path || "");

    if(!path || !path.startsWith("/") || !path.toLowerCase().includes(".pdf")){
      setStatus("ERROR: could not detect absolute PDF path.", false);
      console.warn("BS v2: path detection failed. bs-edit-path=", elPath ? elPath.textContent : null, "modal.dataset=", modal ? modal.dataset : null);
      return;
    }

    const title = (document.getElementById("bs-edit-title")?.value || "").trim();
    const author = (document.getElementById("bs-edit-author")?.value || "").trim();

    setStatus("Saving to server…", true);
  }

  // JS doesn't have True; fix:
})();

(function(){
  function setStatus(msg, ok){
    const st = document.getElementById("bs-edit-status");
    if(!st) return;
    st.textContent = msg || "";
    st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
  }
  function extractPdfPath(s){
    if(!s) return "";
    const t = String(s).trim();
    let m = t.match(/(\/ai_data\/ebooks\/.+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    m = t.match(/(\/.+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    return "";
  }
  async function saveToServer(){
    const modal = document.getElementById("bs-edit-modal");
    const elPath = document.getElementById("bs-edit-path");

    let path = extractPdfPath(elPath ? elPath.textContent : "");
    if(!path && modal && modal.dataset) path = extractPdfPath(modal.dataset.pdfPath || modal.dataset.path || "");

    if(!path || !path.startsWith("/") || !path.toLowerCase().includes(".pdf")){
      setStatus("ERROR: could not detect absolute PDF path.", false);
      console.warn("BS v2: path detection failed. bs-edit-path=", elPath ? elPath.textContent : null, "modal.dataset=", modal ? modal.dataset : null);
      return;
    }

    const title = (document.getElementById("bs-edit-title")?.value || "").trim();
    const author = (document.getElementById("bs-edit-author")?.value || "").trim();

    setStatus("Saving to server…", true);

    try{
      const r = await fetch("/api/override_path", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ path, title, author, hidden: false })
      });
      const j = await r.json().catch(()=> ({}));
      if(!r.ok){
        setStatus("ERROR saving: " + (j.detail ? JSON.stringify(j.detail) : (r.status+" "+r.statusText)), false);
        return;
      }
      setStatus("Saved to server overrides.json ✓", true);
      console.log("BS v2 saved:", j);

      // optional immediate UI update: update the spine tooltip text only
      try{
        const spine = window.__BS_LAST_SPINE_EL || null;
        if(spine && title){
          spine.setAttribute("title", title);
        }
      }catch(e){}
    }catch(e){
      setStatus("ERROR: request failed (see console).", false);
      console.warn("BS v2 request failed", e);
    }
  }

  // Capture clicks in CAPTURE mode and override prior handlers
  document.addEventListener("click", (ev)=>{
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save,#bs-edit-save") : null;
    if(!btn) return;
    ev.preventDefault();
    ev.stopPropagation();
    if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
    saveToServer();
  }, true);

  console.log("BS server save path-from-modal wiring loaded");
})();



// BS SERVER SAVE PATHFROMMODAL v3

// BS SERVER SAVE PATHFROMMODAL v3 (autopatch)
(function(){
  function setStatus(msg, ok){
    // try both status ids (older/newer)
    const st = document.getElementById("bs-edit-status") || document.getElementById("bs-ov-status");
    if(!st) return;
    st.textContent = msg || "";
    st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
  }

  function extractPdfPathFromText(t){
    if(!t) return "";
    const s = String(t);

    // Best: a real absolute path under /ai_data/ebooks ending in .pdf (allow spaces/newlines)
    let m = s.match(/(\/ai_data\/ebooks\/[\s\S]*?\.pdf)/i);
    if(m && m[1]){
      return m[1].replace(/\s+/g, " ").trim();
    }

    // Fallback: any absolute /...pdf
    m = s.match(/(\/[\s\S]*?\.pdf)/i);
    if(m && m[1]){
      return m[1].replace(/\s+/g, " ").trim();
    }
    return "";
  }

  async function saveToServer(btn){
    // Find the modal containing the button
    const modal =
      btn.closest("#bs-edit-modal") ||
      btn.closest("[role='dialog']") ||
      btn.closest("[id*='modal']") ||
      document.getElementById("bs-edit-modal") ||
      document.body;

    // Pull the displayed "Detected path" line from the modal text
    const modalText = modal ? (modal.innerText || modal.textContent || "") : "";
    const path = extractPdfPathFromText(modalText);

    if(!path || !path.startsWith("/") || !path.toLowerCase().includes(".pdf")){
      setStatus("ERROR: could not detect absolute PDF path.", false);
      console.warn("BS v3 path detection failed. modalText(sample)=", modalText.slice(0, 400));
      return;
    }

    const titleEl = document.getElementById("bs-edit-title") || document.getElementById("bs-ov-title");
    const authorEl = document.getElementById("bs-edit-author") || document.getElementById("bs-ov-author");
    const title = (titleEl?.value || "").trim();
    const author = (authorEl?.value || "").trim();

    setStatus("Saving to server…", true);

    try{
      const r = await fetch("/api/override_path", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ path, title, author, hidden: false })
      });
      const j = await r.json().catch(()=> ({}));
      if(!r.ok){
        setStatus("ERROR saving: " + (j.detail ? JSON.stringify(j.detail) : (r.status+" "+r.statusText)), false);
        console.warn("BS v3 save failed:", j);
        return;
      }
      setStatus("Saved to server overrides.json ✓", true);
      console.log("BS v3 saved:", j);
    }catch(e){
      setStatus("ERROR: request failed (see console).", false);
      console.warn("BS v3 request failed", e);
    }
  }

  // Capture clicks on Save in capture phase and override earlier handlers
  document.addEventListener("click", (ev)=>{
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save,#bs-edit-save") : null;
    if(!btn) return;
    ev.preventDefault();
    ev.stopPropagation();
    if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
    saveToServer(btn);
  }, true);

  
// --- ABS PDF PATH EXTRACTOR (autopatch) ---
function __bs_extractAbsPdfPath(text){
  try{
    if(!text) return "";
    const s = String(text);
    // grab first absolute unix path ending in .pdf (allow spaces as %20 not expected here; we look for .pdf)
    const m = s.match(/\/[^<>"']+?\.pdf/);
    return (m && m[0]) ? m[0].trim() : "";
  } catch(e){ return ""; }
}

function getAbsPdfPath(){
  // 1) explicit global, if set
  if (window.__BS_OV_ABS_PATH && String(window.__BS_OV_ABS_PATH).startsWith("/")) return String(window.__BS_OV_ABS_PATH);
  // 2) try from modal detected path text
  const dp = document.getElementById("bs-ov-dpath");
  const fromModal = __bs_extractAbsPdfPath(dp ? dp.textContent : "");
  if (fromModal) return fromModal;
  // 3) try last spine element attributes (title, data-path, data-entry)
  const el = window.__BS_LAST_SPINE_EL;
  if (el){
    const t = el.getAttribute("title") || "";
    const fromTitle = __bs_extractAbsPdfPath(t);
    if (fromTitle) return fromTitle;
    const dp2 = el.dataset ? (el.dataset.path || "") : "";
    if (dp2 and dp2.startswith("/")) return dp2;
    const ent = el.dataset ? (el.dataset.entry or "") : "";
    try{
      if(ent){
        const e = JSON.parse(ent);
        const p = e.pdf_path || e.path || "";
        if (p && String(p).startsWith("/")) return String(p);
      }
    } catch(e){}
  }
  return "";
}
// --- END ABS PDF PATH EXTRACTOR ---

console.log("BS server save path-from-modal v3 loaded");
})();



// BS SERVER SAVE (capture handler v1)
(function(){
  // We capture the last spine + abs path when the editor opens.
  // Even if the existing code changes, this gives us a stable source of truth.
  function detectAbsPdfPath(){
    // 1) best: captured global (set by contextmenu hook)
    try {
      if (window.__BS_OV_ABS_PATH && window.__BS_OV_ABS_PATH.startsWith("/")) return window.__BS_OV_ABS_PATH;
    } catch(e){}

    // 2) modal dataset
    try {
      const m = document.getElementById("bs-ov-modal") || document.getElementById("bs-edit-modal");
      const p = m && m.dataset ? (m.dataset.pdfPath || m.dataset.path || "") : "";
      if (p && p.startsWith("/")) return p;
    } catch(e){}

    // 3) regex scan the modal text for a /ai_data/...pdf path
    try {
      const m = document.getElementById("bs-ov-modal") || document.getElementById("bs-edit-modal");
      const txt = (m && (m.innerText || m.textContent) || "");
      const m1 = txt.match(/(\/ai_data\/ebooks\/[^\s]+?\.pdf)/);
      if (m1 && m1[1]) return m1[1];
      const m2 = txt.match(/(\/home\/[^ \n]+?\.pdf)/);
      if (m2 && m2[1]) return m2[1];
    } catch(e){}

    return "";
  }

  // Capture-phase click handler beats any bubble-phase handlers.
  document.addEventListener("click", async (ev) => {
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save") : null;
    if (!btn) return;

    // Prevent older handlers from running
    ev.preventDefault();
    ev.stopPropagation();
    ev.stopImmediatePropagation();

    const modal = document.getElementById("bs-ov-modal") || document.getElementById("bs-edit-modal");
    const statusEl = document.getElementById("bs-ov-status") || document.getElementById("bs-edit-status");

    const setStatus = (msg, ok=true) => {
      if (!statusEl) return;
      statusEl.textContent = msg || "";
      statusEl.style.color = ok ? "#b6fcb6" : "#ffb6b6";
    };

    const absPath = detectAbsPdfPath();
    if (!absPath) {
      setStatus("ERROR: could not detect absolute PDF path.", false);
      return;
    }

    // Pull values
    const inTitle = document.getElementById("bs-ov-title") || document.getElementById("bs-edit-title");
    const inAuthor = document.getElementById("bs-ov-author") || document.getElementById("bs-edit-author");

    const title = inTitle ? (inTitle.value || "").trim() : "";
    const author = inAuthor ? (inAuthor.value || "").trim() : "";

    try {
      setStatus("Saving to server…", true);
      const r = await fetch("/api/override_path", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({path: absPath, title, author, hidden: false})
      });
      const j = await r.json().catch(()=> ({}));
      if (!r.ok || !j.ok) {
        setStatus("ERROR saving to server: " + (j.detail || r.status), false);
        return;
      }

      setStatus("Saved to server overrides.json ✓", true);

      // Update the last-spine tooltip/text immediately (best-effort)
      try {
        const el = window.__BS_LAST_SPINE_EL;
        if (el) {
          if (title) el.setAttribute("title", title);
          // If spine has text node content, update it (keeps UI responsive)
          if (title && (el.childNodes.length === 1 && el.childNodes[0].nodeType === Node.TEXT_NODE)) {
            el.textContent = title;
          }
        }
      } catch(e){}

    } catch (e) {
      setStatus("ERROR saving: " + (e && e.message ? e.message : e), false);
    }
  }, true);

  console.log("BS server save capture handler loaded");
})();


// BS SERVER SAVE ABS-PATH FIX (autopatch)
(function(){
  const MARK = "BS SERVER SAVE ABS-PATH FIX (autopatch)";

  function findPdfPathFromText(s){
    if(!s) return null;
    // prefer ai_data paths, otherwise any absolute .pdf
    let m = s.match(/(\/ai_data\/[^\n\r]+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    m = s.match(/(\/[^\s\n\r]+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    return null;
  }

  function detectAbsPdfPath(){
    try {
      if (window.__BS_OV_ABS_PATH && typeof window.__BS_OV_ABS_PATH === "string" && window.__BS_OV_ABS_PATH.startsWith("/"))
        return window.__BS_OV_ABS_PATH.trim();
    } catch(e){}

    // Try last spine element
    try {
      const el = window.__BS_LAST_SPINE_EL || null;
      if (el) {
        const p = findPdfPathFromText(el.textContent || "");
        if (p) return p;
      }
    } catch(e){}

    // Try modal text itself
    try {
      const modal =
        document.getElementById("bs-edit-modal") ||
        document.getElementById("bs-ov-modal") ||
        null;
      if (modal) {
        const p = findPdfPathFromText(modal.textContent || "");
        if (p) return p;
      }
    } catch(e){}

    return null;
  }

  function setStatus(msg, ok){
    const st =
      document.getElementById("bs-edit-status") ||
      document.getElementById("bs-ov-status") ||
      null;
    if(!st) return;
    st.textContent = msg || "";
    st.style.color = ok ? "#b6fcb6" : "#ffb6b6";
  }

  function updateSpineVisibleTitle(newTitle){
    try {
      const el = window.__BS_LAST_SPINE_EL || null;
      if(!el || !newTitle) return;

      const txt = (el.textContent || "").split(/\r?\n/).filter(x => x.trim().length);
      if(!txt.length) return;

      txt[0] = newTitle;
      el.textContent = txt.join("\n");
      el.setAttribute("title", newTitle);
    } catch(e){}
  }

  // Capture-phase click handler to beat earlier/local handlers.
  document.addEventListener("click", async (ev) => {
    const btn = ev.target && ev.target.closest ? ev.target.closest("#bs-ov-save, #bs-edit-save") : null;
    if(!btn) return;

    ev.preventDefault();
    ev.stopPropagation();
    try { ev.stopImmediatePropagation(); } catch(e){}

    const titleEl = document.getElementById("bs-edit-title") || document.getElementById("bs-ov-title");
    const authorEl = document.getElementById("bs-edit-author") || document.getElementById("bs-ov-author");
    const title = titleEl ? (titleEl.value || "").trim() : "";
    const author = authorEl ? (authorEl.value || "").trim() : "";

    const absPath = detectAbsPdfPath();
    if(!absPath){
      setStatus("ERROR: could not detect absolute PDF path.", false);
      console.warn("ABS-PATH FIX: could not detect path");
      return;
    }

    try { window.__BS_OV_ABS_PATH = absPath; } catch(e){}

    setStatus("Saving to server…", true);

    const payload = { path: absPath, title: title, author: author, hidden: false };
    console.log("BS UI server-save posting", payload);

    try{
      const r = await fetch("/api/override_path", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const j = await r.json().catch(()=> ({}));
      if(!r.ok){
        setStatus("Server save failed: HTTP " + r.status, false);
        console.warn("Server save failed:", r.status, j);
        return;
      }
      setStatus("Saved to server overrides.json", true);
      updateSpineVisibleTitle(title || "(untitled)");
      console.log("BS server-save OK", j);
    } catch(err){
      setStatus("Server save failed: " + (err && err.message ? err.message : err), false);
      console.warn("Server save exception:", err);
    }
  }, true);

  console.log(MARK);
})();



// BS OV CAPTURE PATH ON CONTEXTMENU (autopatch)
(function(){
  function findPdfPathFromText(s){
    if(!s) return null;
    let m = s.match(/(\/ai_data\/[^\n\r]+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    m = s.match(/(\/[^\s\n\r]+?\.pdf)/i);
    if(m && m[1]) return m[1].trim();
    return null;
  }

  document.addEventListener("contextmenu", (ev)=>{
    try{
      const spine = ev.target && ev.target.closest ? ev.target.closest(".spine") : null;
      if(!spine) return;
      window.__BS_LAST_SPINE_EL = spine;

      // 1) try text content (your DOM already contains /ai_data/...pdf)
      let p = findPdfPathFromText(spine.textContent || "");

      // 2) try title attribute as a fallback
      if(!p) p = findPdfPathFromText(spine.getAttribute("title") || "");

      // 3) try any data attributes as a fallback
      if(!p && spine.dataset){
        p = findPdfPathFromText(spine.dataset.path || "") || findPdfPathFromText(spine.dataset.pdf_path || "");
      }

      if(p){
        window.__BS_OV_ABS_PATH = p;
        console.log("BS ctx path captured:", p);
      } else {
        console.warn("BS ctx path capture: no pdf path found on spine");
      }
    } catch(e){
      console.warn("BS ctx path capture error", e);
    }
  }, true);

  console.log("BS OV CAPTURE PATH ON CONTEXTMENU (autopatch) loaded");
})();

</script>

</body>
</html>
